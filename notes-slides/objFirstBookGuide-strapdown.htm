<!DOCTYPE html>
<html>
<title>PCC Course Slides | CIS 133J Java Programming I</title>
<!--
Theme options include:
amelia, cerulean, cyborg, united,
journal, readable, simplex, slate,
spacelab, spruce, superhero
-->
<xmp theme="spacelab" style="display:none;">
# Objects First with BlueJ
---
## Chapter 2, Part 1
### Main concepts to be covered (Part A)
* fields
* constructors
* methods
* parameters
* assignment statements

### Ticket machines - an external view
* Exploring the behavior of a typical ticket machine
* Using **naive-ticket-machine** project
    * Machines supply tickets of fixed price.
    * How is that price determined?
    * How is money entered into a machine?
    * How does a machine keep track of the money that is entered?

### Ticket machines - an internal view
* Interacting with an object gives us clues about its behavior
* Looking inside allows us to determine how that behavior is provided or implemented

### Basic class structure
```java
public class TicketMachine
{
    // Inner part omitted
}

public class ClassName
{
    // Fields
    // Constructors
    // Methods
}
```

### Keywords with a special meaning in Java
* **public**
* **class**
* **private**
* **int**
* These are also known as *reserved words*

### Fields
* Fields store value in an object.
* They are also known as *instance variables*.
* Fields define the state of an object.
* Use **Inspect** to view the state.
* Some values change often.
* Some change rarely, or not at all.

```java
public class TicketMachine
{
    private int price;
    private int balance;
    private int total;
}
```

### Constructors
* Constructors initialize an object.
* They have the same name as their class.
* They have a close association with fields.
* They store initial values into fields.
* External parameter values for initializing fields.

```java
public TicketMachine(int cost)
{
    price = cost;
    balance = 0;
    total = 0;
}
```

### Methods
* Methods implement the behavior of objects.
* Methods have a consistent structure comprised of a *header* and a *body*.

```java
public int getPrice()
{
    return price;
}
```

### Variables
* Instance variables, aka *fields*
* Class variables, i.e. *static fields*
* Parameters
* Local variables

### Choosing variable names
* Lots of freedom of choice in creating names, but use wisely.
* Choose expressive names to make code easier to understand:
    * **price**
    * **firstName**
    * **numGuests**
* Avoid single letter, cryptic names
    * **w**
    * **t5**
    * **next**

### Scope and lifetime of variables
* Scope - the section of source code from which the variable can be accessed.
* Lifetime - how long the variable continues to exist before it is destroyed.
    * Fields - exist for the life of the object
    * Parameters - exist only during method execution

### Assignment
* Values are stored into fields (and other variables) via assignment statements:
    * *variable = expression;*
    * **price = cost;**
* A variable stores a single value, so any previous value is lost.

### Main concepts to be covered (Part B)
* More on methods
    * Accessor methods
    * Mutator methods
    * Return statements
* Printing
* String concatenation

### Types of methods
* Methods implement the behavior of objects
* *Accessor methods* provide information about an object.
* *Mutator methods* alter the state of an object.
* Other sorts of methods accomplish a variety of tasks.

### Method structure
* The header provides the method's *signature*:
    * **public int getPrice()**
* The header tells us:
    * The name of the method
    * What parameters it takes
    * Whether it returns a result
    * Its visibility to objects of other classes
* The body encloses the method's statements.

### Accessor methods
* A method that simply returns the value of a field is a *getter*.
* An accessor method always has a return type that is not **void**.
* An accessor method returns a value *(result)* of the type given in the header.
* The method will contain a **return** statement to return the value.
* Remember: returning is *not* printing!

### Mutator methods
* Have a similar method structure: *header* and *body*.
* Used to *mutate* (i.e., change) an object's state.
* Achieved through changing the value of one or more fields.
    * Typically contain assignment statements.
    * Often receive parameters.

```java
public void insertMoney(int amount)
{
    balance = balance + amount;
}
```

### **set** mutator methods
* Fields often have dedicated **set** mutator methods, known as *setters*.
* These have a simple, distinctive form:
    * **void** return type
    * method name related to the field name
    * single parameter, with the same type as the type of the field
    * a single assignment statement

### A typical **set** method
```java
public void setDiscount(int amount)
{
    discount = amount;
}
```

### Protective mutators
* A **set** method does not have to assign the parameter to the field.
* The parameter may be checked for validity and rejected if inappropriate.
* Mutators thereby protect fields.
* Mutators support *encapsulation*.

### Printing from methods
```java
public void printTicket()
{
    // Simulate the printing of a ticket
    System.out.println("###################");
    System.out.println("# The BlueJ Line ");
    System.out.println("# Ticket");
    System.out.println("# " + price + " cents.");
    System.out.println("###################");
    System.out.println();

    // Update the total collected with the balance.
    total = total + balance;
    // Clear the balance.
    balance = 0;
}
```

### Method Summary
* Methods implement all object behavior.
* A method has a name and a return type.
    * The return type may be **void**.
    * A non-**void** return type means the method will return a value to its caller.
* A method might take parameters.
    * Parameters bring values in from outside for the method to use.

### Exercise
* Create a class called **Greetings**.
* Add a **String** field called **name**.
* Add a constructor that takes a parameter **newName** and uses it to initialize **name**.
* Add a method called **hello** that takes no parameters and prints "Hello, **name**!", substituting the name.
* Add a method called **goodbye** that prints "Bye, **name**!"

## Chapter 2, Part 2

### Main concepts to be covered
* Conditional statements
* Local variables
* Calling methods

### Reflecting on the ticket machines
* Their behavior is inadequate in several ways:
    * No checks on the amounts entered
    * No refunds
    * No checks for a sensible initialization
* How can we do better?
    * We need more sophisticated behavior.

### Making choices in everyday life
* If I have enough money, I go for a meal
* Otherwise I stay home and watch a movie.

```
if (I have enough money left) {
    go for meal;
} else {
    stay home and watch movie;
}
```

### Making choices in Java
```
if (perform some test) {
    Do these statements if test returned true
} else {
    do this, i.e. if test returned false
}
```

### Making a choice in the ticket machine
```java
public void insertMoney(int amount)
{
    if (amount > 0) {
        balance = balance + amount;
    } else {
        System.out.println(
            "Use a positive amount: " +
            amount
        );
    }
}
```

### Exercise
* In the **Greeting** class:
    * Add a method called **checkAge** that takes an **int** parameter **age** and prints either
        * Eligible to vote
    * or
        * Too young to vote
    * Assume that 18 is the voting age.
* Extra: if too young to vote, print the number of years remaining until eligible.
* Extra: If age entered is negative, print an error

### Variables: a recap
* Fields are one sort of variable:
    * They store values through the life of an object.
    * They are accessible throughout the class.
* Parameters are another sort of variable:
    * They receive values from outside the method.
    * They help a method complete its task.
    * Each call to the method receives a fresh set of values.
    * Parameter values are short lived.

### Local variables
* Methods can define their own, *local* variables:
    * Short-lived, like parameters.
    * The method sets their values - unlike parameters, they do not receive external values.
    * Used for "temporary" calculation and storage.
    * They exist only as long as the method is being executed (*Lifetime*).
    * They are only accessible from within the method (*Scope*).
* A local variable:

```java
public int refundBalance()
{
    int amountToRefund;
    amountToRefund = balance;
    balance = 0;
    return amountToRefund;
}
```
Notice the lack of a visibility modifier in the line
```int amountToRefund;```
which declares the *local* variable.

### Exercise
* In your **Greeting** class, modify the **hello** method as follows:
    * Create a local variable of type **String** called **greetingString**
    * Set **greetingSTring** equal to the string you want to print, such as "Hello, **name**!"
    * Change the print statement to print the variable **greetingString**
* Extra: do the same with **goodbye**

### Review: classes
* Classes contain:
    * Fields - store values that determine an object's *state*.
    * Constructors - initialize objects, particularly their fields.
    * Methods - implement the behavior of objects.

### Review: variables
* Types of variables include:
    * Fields - store an object's state, persist for the lifetime of the object.
    * Parameters - used to receive values into a constructor or method.
    * Local variables - used for short-lived temporary storage.

### Calling methods
* To call a method on the same object:
    * If the method returns a value:
```java
ReturnType var = methodName(params);
```
    * If the method does not return a value:
```java
methodName(params);
```
* To call a method on a different object:
    * If the method returns a value:
```java
ReturnType var = object.methodName(params);
```
    * If the method does not return a value:
```java
object.methodName(params);
```

### Exercise
* In your **Greeting** class, modify the **checkAge** method as follows:
    * Call the **hello** method to print a greeting, *then* print the voting message.
* Extra: call **goodbye** after printing the voting message.
## Chapter 3, Part 1

### Concepts
* Object interaction
* Creating cooperating objects

### Abstraction and modularization
* *Abstraction* is the ability to ignore details of parts to focus attention on a higher level of a problem.
* *Modularization* is the process of dividing a whole into well-defined parts, which can be built and examined separately, and which interact in well-defined ways.

### Modularizing the **clock** display
* One four-digit display?
* Or two two-digit displays?

### Implementation - **NumberDisplay**
```java
public class NumberDisplay
{
    private int limit;
    private int value;

    // Constructor and methods omitted.
}
```

### Implementation - **ClockDisplay**
```java
public class ClockDisplay
{
    private NumberDisplay hours;
    private NumberDisplay minutes;

    // Constructor and methods omitted.
}
```

### Diagrams (see slides)
* Class diagram
* Object diagram

### Objects using objects
* **House** project:
    * **Picture** uses **Circle**, **Square**, and **Triangle**.
* **Greeting** uses **String**.

```java
public class Project {
    private Sample plantSample;
    private Scientist owner;
    // ...
}
```

### Exercise
* In your **greetings** project, create a new class called **Event**.
* Create two fields in **Event** of type **Greeting** named **guest1** and **guest2**
* In the constructor, create two objects with **new**, for example:
```java
guest1 = new Greeting("Jane");
```
* Draw a picture of an **Event** object at run time.

### Data types in Java
* Every data type in Java is either an *object type* or a *primitive type*.
* There are 8 primitive types in the Java language.
* Every other type is an object type, defined in a class.
* Object type:
```java
SomeObject obj;
```
* Primitive type:
```java
int i;
```

### Primitive types vs. Object types
* See slides for diagrams, and how storage differs between the two types.
```java
Customer customer = new Customer();
int totalPoints = 100;
boolean active = true;
It it = new It();
```

### What will be the output?
* What will be the value of **b**?
```java
int a;
int b;
a = 15;
b = a;
a = a + 1;
System.out.println(b);
```
* What will be the value of **b** *this* time?
```java
Person a;
Person b;
a = new Person("Everett");
b = a;
a.setName("Don");
System.out.println(b.getName());
```

### Primitive vs. Object types
* See slides for diagrams demonstrating storage

### Quiz: what is the output?
```java
int x;
int y;
x = 32;
y = x;
x = x + 1;
System.out.println(y);
```
Another example:
```java
Person p1;
Person p2;
p1 = new Person("Molly");
p2 = p1;
p1.setName("Sachi");
System.out.println(p2.getName());
```

### Primitive types
* Integer types
    * **byte**
    * **short**
    * **int**
    * **long**
* Real number types
    * **float**
    * **double**
* Other types
    * **char**
    * **boolean**

### Primitive type variable declarations and initializations
```java
int total;
int num = 55;
int product = num * 10;
long numSeconds;
long bigNum = 10000000000L; // 10 billion
long id = 752348957398025L;

double interest;
double piApproximation = 3.14159;
double average = sum / 100.0;

boolean again;
boolean done = false;
```

### Primitive type exercises
* Declare (and initialize if asked) the following *local variables* in the method **public void calc()**
    1. An **int** named **number**
    2. A **long** named **milesDriven**
    3. A **double** named **epsilon** set to **0.00001**
    4. A **boolean** named **active** set to **true**
    5. An **int** named **x** set to **0**.
* Declare (and initialize if asked) the followinf fields in the class **HighSchool**
    1. A **boolean** named **first**
    2. A **double** named **gpa**
    3. An **int** named **numTracks** set to **10**

### The modulo operator
Consider this source code:
```java
public void increment()
{
    value = (value + 1) % limit; // What is the "%" sign all about?
}
```
* The *division* operator (**/**), when applied to **int** operands, returns the *result* of an *integer division*.
* The *modulo* operator (**%**) returns the *remainder* of an integer division.
* So, generally:
    * 17 / 5 gives result 3, remainder 2
* In Java:
    * 17 / 5 == 3
    * 17 % 5 == 2

### Integer arithmetic examples
* 10 % 3 = 1
* 11 / 5 = 2
* 12 % 6 = 0
* 3 / 8 = 0
* 3 % 8 = 3

### Modulo operator
* For integer **n >= 0**, what are all possible results of:
    * n % 5

### Source code: **NumberDisplay**
```java
public void increment()
{
    value = (value + 1) % limit;
}

public String getDisplayValue()
{
    if (value < 10) {
        return "0" + value;
    } else {
        return "" + value;
    }
}
```

### Exercise
* Create a class called **MathHelper** with an int field named **number**
* Write a constructor that takes a parameter and initializes **number**
* Write a method **getNumAsString** that returns **number** as a String
* Write a method called **square** that returns the square of a number
* Write a method **positive** that returns **true** if **number** is positive.
* Challenge: if you finish early, add the following to your **MathHelper** class:
    * A method called **reciprocal** that returns the reciprocal of **number** as a double
    * A method called **even** that returns **true** if **number** is even
    * A method called **multipleOf** that takes a parameter and returns **true** if **number** is a multiple of the parameter.
    * Rewrite **even** to use **multipleOf**

## Chapter 3, Part 2

### Objects creating objects
```java
public class ClockDisplay
{
    private NumberDisplay hours;
    private NumberDisplay minutes;
    private String DisplayString;

    public ClockDisplay()
    {
        hours = new NumberDisplay(24);
        minutes = new NumberDisplay(60);
        // ...
    }
}
```
* In the class **ClockDisplay**:
    * ``` hours = new NumberDisplay(24);```
        * Here **24** is an *actual* parameter
* In the class **NumberDisplay**:
    * ``` public NumberDisplay(int rolloverlimit) {}```
        * Here **rolloverlimit** is a *formal* parameter

### Creating objects - examples
* Use the **new** operator to create objects
```java
Square wall = new Square();
Project proj1 = new Project();
Car myCar = new Car("Toyota", 0);
```

### Creating objects - exercise
* Write a statement that creates
    * A **Square** object
    * A **Car** object with make "Ford" and 12000 miles
    * A **Qwerty** object (constructor takes no parameters)

### Calling a method on a different object
* aka *external method call*
* When no return value:
```
object.methodName(parameter-list);
```
* Java example:
```java
minutes.increment();
```

### Calling a method on the same object
* aka *internal method call*
* When no return value:
```
methodName(parameter-list)
```
* Java example:
```java
updateDisplay();
```
* No object name required
* Optional: use **this** as object:
```java
this.updateDisplay();
```

### Method calling
```java
public void timeTick()
{
    // external method calls
    minutes.increment();
    if (minutes.getValue() == 0) {
        // it just rolled over!
        hours.increment();
    }
    // internal method call
    updateDisplay();
}
```

### **null**
* **null** is a special value in Java
* An object variable that is **null** is not pointing to any object
* You can test for, and assign, **null**:
```java
hours = null;
if (hours != null) {
    // ...
}
```

### Field default values
* **Object** fields: **null**
* **Int** fields: **0**
* **Double** fields: **0.0**
* **Boolean** fields: **false**

### this with fields
* When a parameter has the same name as a field, it overshadows the field.
* Use **this.fieldName** to refer to the field.
```java
public Dog {
    private String breed;
    public Dog(String breed) {
        this.breed = breed;
    }
    // The "breed" in "this.breed" is a field
    // The "breed" on the right side of the "=" is a parameter
}
```
* Use this technique in *setters*, too!

### Logical operators
* Source code: NumberDisplay
```java
public void setValue(int replacementValue)
{
    if ((replacementValue >= 0) &&
        (replacementValue < limit)) {
            value = replacementValue;
        }
}
```
* **\&\&** i.e. "and", *both* conditions true
* **||** i.e. "or", *either* condition true
* **!** i.e. "not", condition *not true*
* Examples
    * ``` (age >= 18) && validID```
    * ``` (num < 1) || (num > 100)```
    * ``` !done ```
    * ``` (cat != null) && !cat.isPersian()```

### Logical operators exercise
* Write a boolean expression for each condition:
    * **Int** variable **temp** is greater than 70 and less than 80
    * **MathHelper** variable **m** is not positive (use the **positive** method)
    * **Double** variable **amount** is greater than zero or **boolean** variable **override** is true.


## Chapter 4, Part 1
Introduction to collections

### Chapter 4 topics
* Class libraries
* Collections, arrays
* Loops, iterators

### Class libraries aka API
* Useful classes
* We don't have to write everything from scratch
* Java class libraries are organized into *packages*
* Grouping objects is a recurring requirement
    * The **java.util** package contains collection classes
* **java.lang** included automatically in every Java program
    * String
    * Integer
    * System
* **java.util** must be imported
    * ArrayList
    * Date
    * Set

### String API exercise
* Create a String in CodePad:
```java
String s = "Hi there";
```
* Call methods on it and observe the results.
    * toUpperCase: **s.toUpperCase()**
    * toLowerCase
    * length
* Consult the API: what method tells whether a string starts with a certain prefix? Call it.

### The requirement to group objects
* Many applications involve collections of objects:
    * Personal organizers
    * Library catalogs
    * Student-record system
* The number of items to be stored varies.
    * Items added
    * Items deleted

### Without collections
```java
private String name1;
private String name2;
private String name3;
// ...
public void setUpNames()
{
    name1 = new String("Friendly");
    name2 = "Snowball"; // alternate syntax for creating a string
    name3 = "Max";
}
```
* Consult course slides for storage visualization

### Collections with **ArrayList**
* Declare a collection variable:
```java
ArrayList<String> catNames;
```
* Create a collection:
```java
catNames = new ArrayList<String>();
```

### Source code example
```java
import java.util.ArrayList;
// docstring or whatever they call it in Java
public class MusicOrganizer
{
    // Storage for an arbitrary number of file names.
    private ArrayList<String> files;

    // Perform any initialization required for the organizer
    public MusicOrganizer()
    {
        files = new ArrayList<String>();
    }
}
```

### Names exercise
* Create a class called **Names**
* Import **java.util.ArrayList**
* Add a field called **catNames** that is an **ArrayList** of **String**
* In the constructor, assign a **new ArrayList** of **String** to **catNames**
* Add a method **printNames** that prints cat names:
```java
System.out.println(catNames);
```

### Collections with **ArrayList**, continued
* Add to a collection:
```java
catNames.add("Friendly");
catNames.add("Snowball");
catNames.add("Max");
// with each addition, the ArrayList grows to contain more Strings
```
* Get the size of a collection:
```java
int numNames = catNames.size();
```
* Get an element of a collection:
```java
String firstName = catNames.get(0);
```

### Names exercise, continued
* Add a method called **setUpNames** that adds 3 names to **catNames**
* Add a line to **printNames** that prints the *number* of cat names (use the **size** method)
* Add the following method that prints the name at the specified index:
```java
public void printNameAtIndex(int index)
{
    // actions go here
}
```
* *What happens if you try to print an index that doesn't exist?*

### Challenge Names exercise
* Make **printNameAtIndex** print the name's index and then the name (e.g. "2: Max")
* Add a method called **addName** that allows the user to add names to the end of the list
    * What parameter(s) should the method take?
* Look up the **clear** method on **ArrayList** and add a method to **Names** called **clearNames** that clears the list of names.

## Chapter 4, Part 2
### Topics covered:
* Collections
* for-each loops
* comparing String objects

### ArrayList Summary
* Declaration:
```java
ArrayList<Object> myList;
```
* Creation:
```java
myList = new ArrayList<Object>();
```
* Add element:
```java
myList.add(anObject);
```
* Retrieve element:
```java
myList.get(0);
```
* Number of elements:
```java
myList.size();
```
* Remove element:
```java
myList.remove(0);
```

### Features of ArrayList
* Increases capacity as necessary
* Keeps count of the number of elements:
    * **size()** accessor
* Keeps objects in order
* Each object has an *index*
    * Numbering starts at 0!
    * An object's index can change as elements are added and removed

### Removal affects numbering
* Remove from a collection:
```java
catNames.remove(1);
```
* See slides for diagram of memory results

### The general utility of indices
* Using integers to index collections has a general utility:
    * *next* is index + 1
    * *previous* is index - 1
    * *last* is list.size() - 1
    * *the first three* is the items at indices 0, 1, 2
* We could also think about accessing items in sequence: 0, 1, 2, ...

### Retrieving an object
```java
public void listFile(int index)
{
    if (index >= 0 &&
            index < files.size()) {
                String filename = files.get(index);
                System.out.println(filename);
            } else {
                // this is not a valid index
            }
}
```

### Names exercise
* Update **printNameAtIndex** so that if the parameter **index** is out of range, it prints
``` "No name at index x!" ```
    * otherwise it prints the name as before
* Add a method called **removeNameAtIndex** that removes the name at the given index.
    * Challenge: print a message stating the name that was removed.
    * Use the return value of **remove** (see API)

### Iteration
* Iteration allows repeating an action
    * e.g. print all the file names in the organizer.
* Java has several sorts of *loop statements*.
    * **for-each**
    * **for**
    * **while**
    * **do-while**
* Collections: often want to repeat a task once for every object in the collection
    * **for-each** is designed for this

### For-each loop pseudo code
General form of the for-each loop:
```
for (ElementType element : collection) {
    loop body
}
```
Pseudo-code expression of the actions of a for-each loop:
For each *element* in *collection*, do the things in the *loop body*.

### A Java example
```java
// List all the files in the organizer.
public void listAllFiles()
{
    // for each filename in files, print out filename
    for (String filename : files) {
        System.out.println(filename);
    }
}
```

### For-each loop examples
* Given:
```java
ArrayList<String> ids = ...;
```
* Write a for-each loop  that loops over the collection:
```java
for (String id : ids) {
    // actions to repeat
}
```
* Given:
```java
ArrayList<Car> carsOnLot = ...;
```
* Write a for-each loop that iterates over the collection:
```java
for (Car car: carsOnLot)
```

### For-each loop exercises
* Write a for-each loop for each collection:
```java
ArrayList<Integer> codes = ...;
ArrayList<Node> graphNodes = ...;
```

### Names exercise
* Update **printNames** so that it prints each name on a separate line, e.g.:
    * Friendly
    * Snowball
    * Max
* Use a **for-each** loop

### Selective processing
* Statements can be nested, giving greater selectivity:
```java
public void findFiles(String searchString)
{
    for(String filename : files) {
        if (filename.contains(searchString)) {
            System.out.println(filename);
        }
    }
}
```
### Critique of for-each
* Easy to write
* Termination happens naturally
* The collection cannot be changed
* There is no index provided
    * Not all collections are index-based
* It provides *definite iteration* aka *bounded iteration*

### Names exercise
* Add a method **printShortNames** that prints only those names that are less than 5 letters
    * Use an if- statement in the loop
* Challenge: write a method **averageNameLength** that calculates and returns the average length of the cat names.
    * e.g. if the list contains "Friendly" (8 letters), "Snowball" (8), and "Max" (3), it should return ```(8+8+8)/3 = 6.33```

### The String class
* The **String** class is defined in the **java.lang** package.
* It has some special features that need a little care.
* In particular, comparison of **String** objects can be tricky.

### Identity vs. Equality
* Identity
    * *Are these the same object?*
    * Use **==** to compare
* Equality
    * *Do these two have the same value?*
    * e.g. same name, same color
    * Use **equals** method to compare

### String equality
* Use ```if(input.equals("bye"))```, which tests equality, rather than ```if(input=="bye")```, which tests identity.

### String equality examples
```java
if (name1.equals(name2)) {
    System.out.println("Same name!");
}

if (!name1.equals(name2)) {
    System.out.println("Different names");
}
```

### String exercise
* Create a class called **StringComparator**
* Write a method called **sameNames** with the signature below that takes two **String** parameters and returns true if they are the same (i.e., have the same value)
```java
public boolean sameNames(String name1, String name2)
```

### Five slides' worth of diagrams
* See diagrams in slides for graphical picture of the memory events pertaining to String identity, equality

### The problem with Strings
* The compiler merges identical **String** literals in the program code.
    * The result is reference equality for apparently distinct **String** objects.
* But this cannot be done for identical strings that arise outside the program's code
    * e.g., from user input

### The auction project
* The **auction** project provides further illustration of collections and iteration.
* Examples of using **null**
* Anonymous objects.
* Chaining method calls.

### null
* Used with object types
* Used to indicate *no object*
* We can test if an object variable holds the **null** value:
```java
if(highestBid == null) {
    // do something
}
```
* Used to indicate *no bid yet*

### Anonymous objects
* Objects are often created and handed on elsewhere immediately:
```java
Lot furtherLot = new Lot(...);
lots.add(furtherLot);
```
* We don't really need **furtherLot**:
```java
lots.add(new Lot(...));
```

### Chaining method calls
* Methods often return objects
* We often immediately call a method on a returned object.
```java
Bid bid = lot.getHighestBid();
Person bidder = bid.getBidder();
```
* We can use the anonymous object concept and *chain* method calls:
```java
lot.getHighestBid().getBidder()
```
* Each method in the chain is called on the object returned from the previous method call in the chain.
```java
String name = lot.getHighestBid().getBidder().getName();
```

</xmp>
    <script src="http://strapdownjs.com/v/0.2/strapdown.js"></script>
</html>
